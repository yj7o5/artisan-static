---
title: '01 - Mental model for learning comp. languages and maintaining a balance'
date: 2021-08-08
image: https://st.depositphotos.com/1044727/5166/i/380/depositphotos_51668925-stock-photo-programing-languages.jpg 
comments: false
---

Ever since the advent of computers in our world we have seen an invention numerous computer languages. A quick  search on [wikipedia](https://www.wikiwand.com/en/List_of_programming_languages) shows us the list of programming languages that exists to-date. Each having it's own purpose in space providing various flavors, features, and ergonomics enabling us to solve problems in efficient ways. With this increase in the number of languages brings us the challenge of deciding which one to pick and which one not to. We always get bogged down by the fact, if a certain language or framework will hinder our ability to grow in future or if this is something that has the scope in future. I personally to this day got drawn into this conundrum, and I believe most of you too, the fact that the pace at which our industry changes with inventions of various frameworks, libraries, and as such it get's overwhelming as to which path to take and which not to.

Among the many languages of modern day, we have seen a huge uptick in [Rust](https://www.rust-lang.org) and it's now widely adopted as the go-to systems language due to it's memory safety feature, speed, and reliability. In fact, the recent [StackOverflow survey 2020](https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved) reveals that for the sixth year in a row, Rust has been the most loved language.

Now this makes one think whether should I forget learning the tech stack I am currently on or the language I am learning now and put all I my focus and attention towards Rust and the Rust ecosystem, even if I like it or not. Theres definitely something to it that attracts the attention of many people in the industry and thus the stats from StackOverflow speaks for itself. But from an individual developer point-of-view the question becomes how should one effectively get to benefit from the likes of various languages we have and how it will play a role in our growth in the tech world, let alone the various frameworks or libraries. 

I myself have had for the most part exposure to C# and the .NET world/ecosystem. For the last few years both professionaly and during my free time I have spent learning and trying understanding the deep/internal mechanics of the language and framework. But that is not to say that I did not spend time with other languages such as java, python, go, haskell or even assembly to some degree. By the way, speaking of assembly, I would highly recommend reading this book, [Nand2tetris](https://www.nand2tetris.org), it teaches writing the whole stack all the way from writing logic gates, to assembler to compiler and eventually building tetris with it. 

So, after having myself involved in tapping a bit of toe in different spaces, doesn't mean I have become an _expert_ in all of them, definitely not. But I have gotten an appreciation and a perspective of how to express logic in various languages. This has given me a picture in mind and that is to perceive various computer languages is in a form of rows and columns, yes, you guessed it right - A Matrix. In this rough picture below, your columns define the various languages(obviously there are many many more, these are just that came to mind off top my head) that we have in our space while the rows define the various level of abstractions each go through until they spit out the specific machine instructions or your good ol' 0's and 1's, if you will.

![Languages Matrix Chart](/images/1-lang-matrix.png)

If we scope the problem in this well defined matrix/space it gives us a mental model to picture and a simple way to internalize these out. The general idea is that you pick one column, i.e., one single language out of the many that you have and try to gain a deep understanding of while going thru all the rows of that column. Let's say if you pick C#, you go as deep as possible so as to you can picture the specific IL and JITed code that the compiler would spitting out. As an example, Linus Tarvold in this [video](https://www.youtube.com/watch?v=CYvJPra7Ebk) explains why he loves C, it's not because it's the mother of all the languages(which to some degree you can argue pretty much is) or that majority people love it, but more so because he can actually envision the exact assembly that will get output. What this means is that you gain so much control when having a deep understanding of the system you're in such that you can make really interesting design decisions. This will allow you to become a true Subject Matter Expert with-in the that specific "column" or community that your contributes could help out the community and be as effective as possible with your contributions. 

On the otherhand, while you have your focus and attention on one specific column from the matrix, you should not forego the fact that there are more than 1 column in this matrix. We as an individual don't really have the capacity to consume everything out of this matrix meaning trying to cover all the rows and all the columns, maybe someone is out there and if there is then s/he definitely the G.O.A.T. So, continuing on the other columns serves as a way for us to explore what's out in the world and how different languages play in the whole grand scheme of the things. As mentioned earlier the language designers design language with one specific goal in mind and they are trying to solve a particular problem as in example of Rust vs C where Rust completely outcasts C is the memory safety feature and non-GC environment. That there are many other examples and comparisons we can make, but I can leave the conversation for some time later. Going back to columns and expanding outwards, it gives a perspective with which you can draw a line out and in fact bring those ideas out into the specific column you're expert in. As a matter of fact, we can already see how C# 8-9 have brought various pattern-matching features that which for a long time have already been and can be seen in Rust, Python, etc. So while you're reaching out to other columns you're not trying to become the true expert with in that column because as mentioned earlier if you do you will gradually start lose the effectiveness that you had gained in the original "column" or space as mentioned in the earlier example of C#/dotnet. In an article, Ayende, describes it really well there is a [difference between knowing python and **knowing** python](https://ayende.com/blog/191617-C/difference-between-knowing-python-and-knowing-python). You can take that phrase and replace Python with an underscore such as "there is a difference between knowing ____ and **knowing** _____" where the underscore can be replaced with any of the other columns shown above. Again, you attain enough knowledge to be able to at-least read and write out the code in the language and understand some of the design decisions and features that an author made so as to broaden your perspective.

Therefore, this mental model allows an individual to surround him/herself in a confined space under which to operate over while not getting too overwhelmed with the vast amount of languages that exists today. The idea is simple, i.e. to follow 1 and only 1 "column" and going deep down while expanding outwards to other columns but not going deep down the rows so as to maintain a balance, thus keeping your effectiveness in the community and enjoying the nugets that other languages provide. This matrix model should give you a clear picture to follow the road ahead or if you don't already have clear path define then a template to start over with and finally become a true Subject Matter Expert.